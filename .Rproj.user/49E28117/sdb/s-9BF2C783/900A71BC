{
    "contents" : "##cacheMatrix.R\n##provides a data structure for storing a matrix and its inverse, and an accessor method for the inverse that uses cached values for +\n##      efficiency.\n##\n##\n##functions:    makeCacheMatrix - data structure that stores a matrix and its inverse, and provides basic accessors.\n##              cacheSolve - takes a cache matrix, and returns the inverse, using cached results or updating the cache as needed.\n\n## Code is EXCESSIVELY COMMENTED so new R programmers can see why everything is the way it is.\n\n\n\n## makeCacheMatrix - Stores data for a matrix and possibly its inverse. Returns a list of accessor methods.\n## Argument:            matrixToInitialize - a matrix to store\n## Constructor:         makeCacheMatrix\n## accessor methods:    get/set for the matrix\n##                      getInverse/setInverse for the inverse of the given matrix.\n##\n## No error checking, local validation, or computation of data, it's just a data structure.\nmakeCacheMatrix <- function(matrixToInitialize = matrix()) {\n        \n        ##this puts the matrix and inverse data in the scope of this function/object.\n        ##i gotta say, overloading function() is a pretty opaque way of dealing with something so fundamental to OOP.\n        ##Also, i diverge from the example here to clarify the scope of the argument.\n        cachedMatrix <- matrixToInitialize\n        cachedInverse <- NULL\n        \n        ##set initializes the external storage and stores a matrix in it. Inverse is initialized but not computed.\n        set <- function(matrixToInitialize) {\n                #note that this locally scoped matrixToInitialize takes precedence over the function argument.\n                #also '<<-' digs into the (constructor) function's scope, allowing the data to persist.\n                cachedMatrix <<- matrixToInitialize\n                \n                #if you're reinitializing the matrix, the old inverse is NO DANG GOOD NO MO\n                cachedInverse <<- NULL\n        }\n        \n        ## get retrieves the primary data stored in the CacheMatrix, the matrix itself\n        get <- function() {\n                ## return the cached matrix\n                cachedMatrix\n        }\n        \n        \n        ##similar get/set methods for the inverse, cachedInverse.\n        setInverse <- function(inverseToInitialize) {\n                cachedInverse <<- inverseToInitialize\n        }\n        getInverse <- function() cachedInverse\n        \n        \n        ##the return value for calling this function is a list of the methods it contains.\n        ##this exposes them to external environments, allowing them to be called externally.\n        \n        ##the a = a syntax provides names to the methods using the named object capability of R lists. 'handle' = 'pointer to function'.\n        ##i'm personally of the opinion that distinct things need distinct names but wtf do i know. I'm following the rails here.\n        \n        ##returning these accessor methods, that depend on the data fields in the main function scope prevents the whole object +\n        ##from being garbage collected as long as this list is not collected.\n        list(get = get, set = set, getInverse = getInverse, setInverse = setInverse)\n}\n\n\n## cacheSolve - searches for a cached inverse of a cacheMatrix, returns it if availiable, and computes/caches it if not.\n## Arguments:           x - a cacheMatrix to get the inverse from\n##                      ... - extra arguments get passed on to solve() if the result aint cached already.\n## THIS FUNCTION CAN HAVE SIDE EFFECTS: if x hain't got an inverse to start, by golly it will by the end of this function.\n## no error checking or even input validation.\ncacheSolve <- function(x, ...) {\n        \n        ## first, we see if we can do this the easy way, without computation.\n        if (is.null(x$getInverse()) == FALSE) {\n                \n                ## extract the inverse so it doesn't prohibit garbage collection of the original (pass by value, not reference)\n                temp <- x$getInverse()\n                \n                #break, returning a\n                return(temp)\n        }\n        ##if execution proceeds to this point, we need to get that inverse.\n        ##what follows is implcitly an 'else' to the 'if' above.\n        \n        \n        ##from inside out:\n        ## x.get() - gets the matrix x stores\n        ## solve() - computes the inverse of the stored matrix, passing along '...'.\n        temp <- solve(x$get(),...)\n        \n        ##update x\n        x$setInverse(temp)\n        \n        ##return the inverse at the end of execution\n        temp\n        \n}\n",
    "created" : 1443344748858.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "243855071",
    "id" : "900A71BC",
    "lastKnownWriteTime" : 1443350062,
    "path" : "~/RCoursera/week3/ProgrammingAssignment2/ProgrammingAssignment2/cachematrix.R",
    "project_path" : "cachematrix.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "type" : "r_source"
}